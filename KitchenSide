import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  SafeAreaView,
  ScrollView,
  Text,
  StyleSheet,
  View,
  TouchableOpacity,
  Alert,
  RefreshControl,
  ActivityIndicator,
  StatusBar,
} from "react-native";
import { createClient } from "@supabase/supabase-js";

// -------------------------------
// CONSTANTS & CONFIGURATION
// -------------------------------
const SUPABASE_URL = "https://tbfhhplpwqelstuzmlmh.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiZmhocGxwd3FlbHN0dXptbG1oIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM0ODY0NzYsImV4cCI6MjA3OTA2MjQ3Nn0.7v1snYLBqDEvNfGS9D74j_CqAUteZSI7oZxKrPFifPw";

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const OrderStatus = {
  PENDING: "pending",
  PREPARING: "preparing",
  READY: "ready",
  COMPLETED: "completed",
};

const Colors = {
  primary: "#00ff00",
  secondary: "#32CD32",
  danger: "#ff4444",
  warning: "#FFA500",
  background: "#1a1a1a",
  card: "#2d2d2d",
  text: "#ffffff",
  textSecondary: "#aaaaaa",
  success: "#00cc00",
  error: "#cc0000",
};

// -------------------------------
// REUSABLE COMPONENTS
// -------------------------------
const OrderCard = ({ order, onComplete, onDelete }) => {
  const getStatusColor = (status) => {
    const statusColors = {
      [OrderStatus.PENDING]: Colors.warning,
      [OrderStatus.PREPARING]: Colors.primary,
      [OrderStatus.READY]: Colors.secondary,
      [OrderStatus.COMPLETED]: Colors.success,
    };
    return statusColors[status] || Colors.textSecondary;
  };

  const formatTime = (timestamp) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  const calculateWaitTime = (createdAt) => {
    const created = new Date(createdAt);
    const now = new Date();
    const diffMinutes = Math.floor((now - created) / (1000 * 60));
    
    if (diffMinutes < 1) return "Just now";
    if (diffMinutes === 1) return "1 min ago";
    return `${diffMinutes} mins ago`;
  };

  return (
    <View style={styles.kitchenOrderCard}>
      <View style={styles.orderHeader}>
        <View style={styles.orderTitleRow}>
          <Text style={styles.orderId}>Order #{order.id}</Text>
          <View style={[styles.statusBadge, { backgroundColor: getStatusColor(order.status) }]}>
            <Text style={styles.statusText}>{order.status.toUpperCase()}</Text>
          </View>
        </View>
        <View style={styles.orderMeta}>
          <Text style={styles.orderTime}>{formatTime(order.created_at)}</Text>
          <Text style={styles.waitTime}>{calculateWaitTime(order.created_at)}</Text>
        </View>
      </View>

      <Text style={styles.customerName}>
        üë§ {order.custumerName || "Walk-in Customer"}
      </Text>

      <View style={styles.itemsSection}>
        <Text style={styles.itemsLabel}>Items ({order.Order_items?.length || 0}):</Text>
        {order.Order_items?.map((item, index) => (
          <View key={index} style={styles.itemRow}>
            <Text style={styles.itemName}>‚Ä¢ {item.name}</Text>
            <Text style={styles.itemPrice}>{item.price}</Text>
          </View>
        ))}
      </View>

      <View style={styles.orderFooter}>
        <Text style={styles.totalAmount}>
          Total: ${parseFloat(order.total_price || 0).toFixed(2)}
        </Text>
        
        <View style={styles.actionButtons}>
          <TouchableOpacity
            style={[styles.actionButton, styles.completeButton]}
            onPress={() => onComplete(order.id)}
          >
            <Text style={styles.actionButtonText}>‚úì Complete</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.actionButton, styles.deleteButton]}
            onPress={() => onDelete(order.id)}
          >
            <Text style={styles.actionButtonText}>üóëÔ∏è Delete</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const KitchenToggle = ({ isOpen, onToggle, isLoading }) => (
  <TouchableOpacity
    style={[
      styles.kitchenToggle,
      { 
        backgroundColor: isOpen ? Colors.success : Colors.error,
        opacity: isLoading ? 0.6 : 1
      }
    ]}
    onPress={onToggle}
    disabled={isLoading}
  >
    <Text style={styles.kitchenToggleText}>
      {isOpen ? "üè™ KITCHEN OPEN" : "üö´ KITCHEN CLOSED"}
    </Text>
    {isLoading && (
      <ActivityIndicator size="small" color={Colors.text} style={styles.toggleSpinner} />
    )}
  </TouchableOpacity>
);

const LoadingSpinner = () => (
  <View style={styles.loadingContainer}>
    <ActivityIndicator size="large" color={Colors.primary} />
    <Text style={styles.loadingText}>Loading orders...</Text>
  </View>
);

// -------------------------------
// MAIN KITCHEN SCREEN COMPONENT
// -------------------------------
const KitchenScreen = () => {
  const [orders, setOrders] = useState([]);
  const [isKitchenOpen, setIsKitchenOpen] = useState(true);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isTogglingKitchen, setIsTogglingKitchen] = useState(false);

  // -------------------------------
  // DATA FETCHING FUNCTIONS
  // -------------------------------
  const loadKitchenStatus = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from("settings")
        .select("kitchen_open")
        .eq("id", 1)
        .single();

      if (!error && data) {
        setIsKitchenOpen(data.kitchen_open);
      }
    } catch (error) {
      console.error("Error loading kitchen status:", error);
    }
  }, []);

  const loadOrders = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from("orders")
        .select("*")
        .neq("status", OrderStatus.COMPLETED)
        .is("deleted_at", null)
        .order("created_at", { ascending: true }); // Show oldest first

      if (!error) {
        setOrders(data || []);
      } else {
        console.error("Error loading orders:", error);
        Alert.alert("Error", "Failed to load orders");
      }
    } catch (error) {
      console.error("Error loading orders:", error);
      Alert.alert("Error", "Failed to load orders");
    } finally {
      setIsLoading(false);
      setIsRefreshing(false);
    }
  }, []);

  const refreshData = useCallback(async () => {
    setIsRefreshing(true);
    await Promise.all([loadOrders(), loadKitchenStatus()]);
  }, [loadOrders, loadKitchenStatus]);

  // -------------------------------
  // KITCHEN MANAGEMENT FUNCTIONS
  // -------------------------------
  const toggleKitchen = useCallback(async () => {
    setIsTogglingKitchen(true);
    const newState = !isKitchenOpen;

    try {
      const { error } = await supabase
        .from("settings")
        .update({ kitchen_open: newState })
        .eq("id", 1);

      if (!error) {
        setIsKitchenOpen(newState);
        Alert.alert(
          "Kitchen Status Updated",
          `Kitchen is now ${newState ? "OPEN" : "CLOSED"}`,
          [{ text: "OK" }]
        );
      } else {
        throw error;
      }
    } catch (error) {
      console.error("Error toggling kitchen:", error);
      Alert.alert("Error", "Failed to update kitchen status");
    } finally {
      setIsTogglingKitchen(false);
    }
  }, [isKitchenOpen]);

  // -------------------------------
  // ORDER MANAGEMENT FUNCTIONS
  // -------------------------------
  const completeOrder = useCallback(async (orderId) => {
    try {
      const { error } = await supabase
        .from("orders")
        .update({ status: OrderStatus.COMPLETED })
        .eq("id", orderId);

      if (error) throw error;

      // Optimistic update
      setOrders(prev => prev.filter(order => order.id !== orderId));
      
      Alert.alert("Success", "Order marked as completed!");
    } catch (error) {
      console.error("Error completing order:", error);
      Alert.alert("Error", "Unable to complete order");
      // Reload to ensure sync
      loadOrders();
    }
  }, [loadOrders]);

  const deleteOrder = useCallback((orderId) => {
    Alert.alert(
      "Delete Order",
      "Are you sure you want to delete this order? This action cannot be undone.",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: async () => {
            try {
              const { error } = await supabase
                .from("orders")
                .update({ deleted_at: new Date().toISOString() })
                .eq("id", orderId);

              if (error) throw error;

              // Optimistic update
              setOrders(prev => prev.filter(order => order.id !== orderId));
              
              Alert.alert("Success", "Order deleted successfully!");
            } catch (error) {
              console.error("Error deleting order:", error);
              Alert.alert("Error", "Unable to delete order");
              loadOrders();
            }
          },
        },
      ]
    );
  }, [loadOrders]);

  const updateOrderStatus = useCallback(async (orderId, newStatus) => {
    try {
      const { error } = await supabase
        .from("orders")
        .update({ status: newStatus })
        .eq("id", orderId);

      if (error) throw error;

      // Optimistic update
      setOrders(prev => prev.map(order => 
        order.id === orderId ? { ...order, status: newStatus } : order
      ));
    } catch (error) {
      console.error("Error updating order status:", error);
      Alert.alert("Error", "Failed to update order status");
      loadOrders();
    }
  }, [loadOrders]);

  // -------------------------------
  // USE EFFECTS
  // -------------------------------
  useEffect(() => {
    refreshData();
  }, [refreshData]);

  useEffect(() => {
    // Real-time subscription for orders
    const orderSubscription = supabase
      .channel('orders')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'orders' 
        }, 
        () => {
          loadOrders();
        }
      )
      .subscribe();

    // Real-time subscription for kitchen status
    const settingsSubscription = supabase
      .channel('settings')
      .on('postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'settings'
        },
        () => {
          loadKitchenStatus();
        }
      )
      .subscribe();

    return () => {
      orderSubscription.unsubscribe();
      settingsSubscription.unsubscribe();
    };
  }, [loadOrders, loadKitchenStatus]);

  // -------------------------------
  // MEMOIZED VALUES
  // -------------------------------
  const pendingOrders = useMemo(() => 
    orders.filter(order => order.status === OrderStatus.PENDING), 
    [orders]
  );

  const preparingOrders = useMemo(() => 
    orders.filter(order => order.status === OrderStatus.PREPARING), 
    [orders]
  );

  const readyOrders = useMemo(() => 
    orders.filter(order => order.status === OrderStatus.READY), 
    [orders]
  );

  // -------------------------------
  // RENDER FUNCTIONS
  // -------------------------------
  const renderOrderSection = (title, orderList, color) => (
    orderList.length > 0 && (
      <View style={styles.section}>
        <View style={[styles.sectionHeader, { borderLeftColor: color }]}>
          <Text style={styles.sectionTitle}>{title}</Text>
          <Text style={styles.sectionCount}>({orderList.length})</Text>
        </View>
        {orderList.map((order) => (
          <OrderCard
            key={order.id}
            order={order}
            onComplete={completeOrder}
            onDelete={deleteOrder}
          />
        ))}
      </View>
    )
  );

  // -------------------------------
  // MAIN RENDER
  // -------------------------------
  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor={Colors.background} />
      
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={refreshData}
            colors={[Colors.primary]}
            tintColor={Colors.primary}
          />
        }
      >
        <Text style={styles.title}>üßë‚Äçüç≥ KITCHEN DISPLAY</Text>

        <KitchenToggle
          isOpen={isKitchenOpen}
          onToggle={toggleKitchen}
          isLoading={isTogglingKitchen}
        />

        <View style={styles.statsContainer}>
          <View style={styles.statItem}>
            <Text style={styles.statNumber}>{orders.length}</Text>
            <Text style={styles.statLabel}>Total Orders</Text>
          </View>
          <View style={styles.statItem}>
            <Text style={styles.statNumber}>{pendingOrders.length}</Text>
            <Text style={styles.statLabel}>Pending</Text>
          </View>
          <View style={styles.statItem}>
            <Text style={styles.statNumber}>{preparingOrders.length}</Text>
            <Text style={styles.statLabel}>Preparing</Text>
          </View>
        </View>

        {isLoading ? (
          <LoadingSpinner />
        ) : orders.length === 0 ? (
          <View style={styles.emptyState}>
            <Text style={styles.emptyStateEmoji}>üì≠</Text>
            <Text style={styles.emptyStateText}>No active orders</Text>
            <Text style={styles.emptyStateSubtext}>
              New orders will appear here automatically
            </Text>
          </View>
        ) : (
          <>
            {renderOrderSection("Ready for Pickup", readyOrders, Colors.success)}
            {renderOrderSection("Being Prepared", preparingOrders, Colors.warning)}
            {renderOrderSection("New Orders", pendingOrders, Colors.primary)}
          </>
        )}
      </ScrollView>
    </SafeAreaView>
  );
};

// -------------------------------
// STYLES
// -------------------------------
const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: Colors.background 
  },
  scrollContent: { 
    padding: 16,
    paddingBottom: 20 
  },
  title: {
    fontSize: 28,
    fontWeight: "bold",
    color: Colors.primary,
    textAlign: "center",
    marginBottom: 20,
  },
  kitchenToggle: {
    padding: 16,
    borderRadius: 12,
    alignItems: "center",
    marginBottom: 20,
    flexDirection: "row",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  kitchenToggleText: { 
    color: Colors.text, 
    fontSize: 18, 
    fontWeight: "bold",
    marginRight: 8,
  },
  toggleSpinner: {
    marginLeft: 8,
  },
  statsContainer: {
    flexDirection: "row",
    justifyContent: "space-around",
    marginBottom: 20,
    backgroundColor: Colors.card,
    padding: 16,
    borderRadius: 12,
  },
  statItem: {
    alignItems: "center",
  },
  statNumber: {
    fontSize: 24,
    fontWeight: "bold",
    color: Colors.primary,
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    color: Colors.textSecondary,
    fontWeight: "600",
  },
  section: {
    marginBottom: 20,
  },
  sectionHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 12,
    paddingLeft: 12,
    borderLeftWidth: 4,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: "bold",
    color: Colors.text,
    marginRight: 8,
  },
  sectionCount: {
    fontSize: 16,
    color: Colors.textSecondary,
    fontWeight: "600",
  },
  kitchenOrderCard: {
    backgroundColor: Colors.card,
    padding: 16,
    marginBottom: 12,
    borderRadius: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
  },
  orderHeader: {
    marginBottom: 12,
  },
  orderTitleRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  orderId: { 
    fontSize: 18, 
    color: Colors.text, 
    fontWeight: "bold" 
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 10,
    color: Colors.text,
    fontWeight: "bold",
  },
  orderMeta: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  orderTime: { 
    color: Colors.textSecondary, 
    fontSize: 12 
  },
  waitTime: { 
    color: Colors.warning, 
    fontSize: 12,
    fontWeight: "600",
  },
  customerName: { 
    color: Colors.text, 
    fontSize: 16, 
    marginBottom: 12,
    fontWeight: "600",
  },
  itemsSection: { 
    marginBottom: 12 
  },
  itemsLabel: { 
    color: Colors.textSecondary, 
    marginBottom: 8,
    fontWeight: "600",
  },
  itemRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 4,
  },
  itemName: { 
    color: Colors.text, 
    fontSize: 14,
    flex: 1,
  },
  itemPrice: {
    color: Colors.textSecondary,
    fontSize: 14,
  },
  orderFooter: {
    borderTopWidth: 1,
    borderTopColor: Colors.textSecondary,
    paddingTop: 12,
  },
  totalAmount: {
    color: Colors.primary,
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
    textAlign: "center",
  },
  actionButtons: { 
    flexDirection: "row", 
    gap: 8 
  },
  actionButton: {
    flex: 1,
    padding: 12,
    borderRadius: 8,
    alignItems: "center",
    justifyContent: "center",
  },
  completeButton: {
    backgroundColor: Colors.success,
  },
  deleteButton: {
    backgroundColor: Colors.error,
  },
  actionButtonText: { 
    color: Colors.text, 
    fontWeight: "bold",
    fontSize: 14,
  },
  emptyState: { 
    alignItems: "center", 
    marginTop: 50 
  },
  emptyStateEmoji: {
    fontSize: 48,
    marginBottom: 16,
  },
  emptyStateText: { 
    color: Colors.textSecondary, 
    fontSize: 20,
    marginBottom: 8,
  },
  emptyStateSubtext: {
    color: Colors.textSecondary,
    fontSize: 14,
    textAlign: "center",
  },
  loadingContainer: {
    alignItems: "center",
    justifyContent: "center",
    padding: 40,
  },
  loadingText: {
    color: Colors.textSecondary,
    marginTop: 12,
    fontSize: 16,
  },
});

export default KitchenScreen;
